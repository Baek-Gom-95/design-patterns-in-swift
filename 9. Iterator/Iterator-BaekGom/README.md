# Iterator 패턴

## **이터레이터 패턴이란?**

Iterator Pattern은 list, stack, tree 등과 같은 기본적인 표현을 노출하지 않고 객체를 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다. Swift에서는 IteratorProtocol을 채택하여 for문을 사용하여 반복할 수 있는 타입을 정의하게 됩니다.

## **이터레이터 패턴은 언제 쓰나요?**

객체들의 그룹을 유지하는 타입이 있고 이를 반복문에서 사용하고 싶을 때 iterator pattern을 사용합니다. Collection은 프로그래밍을 할 때 가장 많이 사용하는 데이터 타입 중 하나입니다. 이러한 Collection은 사실 그냥 하나의 컨테이너일 뿐인데요, 다른 코드에서 Collection의 요소들을 사용할 수 있도록 접근하는 방법을 제공하지 않으면 그냥 데이터 덩어리에 불과하게 되겠죠.

 

Collection의 모든 요소에 접근하는 방법을 제공하기 위해 다양한 방법을 구현할 수 있을 텐데요, 만약 트리라는 Collection이 존재한다면, DFS, BFS과 같은 알고리즘을 Collection에 추가하는 것은 데이터를 저장한다는 책임을 갖는 Collection의 입장에서는 이상할 수 있습니다.

 

따라서 이러한 알고리즘은 Iterator라는 별도의 객체로 구현하는 방법이 Iterator 패턴입니다. 알고리즘 자체를 구현하는 것 외에도 Iterator 객체는 현재 위치나 끝까지 남은 요소 수와 같은 세부 정보를 캡슐화하여 여러 개의 반복문이 동시에 동작하더라도 서로 독립적으로 사용할 수 있습니다.

 

이러한 Iterator는 Collection의 요소를 가지고오는 하나의 방법을 제공하는데요, 클라이언트는 아무것도 반환하지 않을 때까지 반복문을 통해 요소를 가지고 오게 됩니다. 또한 특정 Collection을 탐색하는 특별한 방법이 필요한 경우 Collection, Client를 수정하지 않고 새로운 Iterator 클래스만 만들어주면 됩니다.

## **이터레이터 패턴의 결과**
**장점**

Single Responsibility Principle : 순회 알고리즘을 별도의 클래스로 추출하여 단일 책임 원칙을 지킬 수 있습니다.
Open / Closed Principle : 새로운 타입의 컬렉션 및 Iterator를 구현하더라도 기존 코드에서 사용할 수 있습니다.
각각의 Iterator 객체에는 자체적인 반복 상태가 존재하기 때문에 동일한 컬렉션을 병렬로 처리할 수도 있습니다.
각각의 Iterator 객체에는 자체적인 반복 상태가 존재하기 때문에 반복을 지연하거나 다시 실행할 수도 있습니다.
**단점**

앱이 단순한 Collection만 필요로 하는 경우 Iterator Pattern은 굳이 필요 없을 수도 있습니다.
Iterator를 사용하는 것은 몇몇 Collection의 요소를 직접 처리하는 것 보다 비효율적일 수 있습니다.
